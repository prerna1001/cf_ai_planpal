{"version":3,"file":"src-C8K3lu37.js","names":["genericObservability: Observability","parsed: unknown","response: RPCResponse","ctx","proto","theError: unknown","schedule: Schedule<T>","transportType: TransportType","headerTransportOpts: SSEClientTransportOptions","url","mcpState: MCPServersState","agentId","map: Record<string, unknown>","serialisableEmail: AgentEmail","chunks: Uint8Array[]","options"],"sources":["../src/observability/index.ts","../src/index.ts"],"sourcesContent":["import { getCurrentAgent } from \"../index\";\nimport type { AgentObservabilityEvent } from \"./agent\";\nimport type { MCPObservabilityEvent } from \"./mcp\";\n\n/**\n * Union of all observability event types from different domains\n */\nexport type ObservabilityEvent =\n  | AgentObservabilityEvent\n  | MCPObservabilityEvent;\n\nexport interface Observability {\n  /**\n   * Emit an event for the Agent's observability implementation to handle.\n   * @param event - The event to emit\n   * @param ctx - The execution context of the invocation (optional)\n   */\n  emit(event: ObservabilityEvent, ctx?: DurableObjectState): void;\n}\n\n/**\n * A generic observability implementation that logs events to the console.\n */\nexport const genericObservability: Observability = {\n  emit(event) {\n    // In local mode, we display a pretty-print version of the event for easier debugging.\n    if (isLocalMode()) {\n      console.log(event.displayMessage);\n      return;\n    }\n\n    console.log(event);\n  }\n};\n\nlet localMode = false;\n\nfunction isLocalMode() {\n  if (localMode) {\n    return true;\n  }\n  const { request } = getCurrentAgent();\n  if (!request) {\n    return false;\n  }\n\n  const url = new URL(request.url);\n  localMode = url.hostname === \"localhost\";\n  return localMode;\n}\n","import type { env } from \"cloudflare:workers\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nimport type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nimport type {\n  Prompt,\n  Resource,\n  ServerCapabilities,\n  Tool\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { parseCronExpression } from \"cron-schedule\";\nimport { nanoid } from \"nanoid\";\nimport { EmailMessage } from \"cloudflare:email\";\nimport {\n  type Connection,\n  type ConnectionContext,\n  type PartyServerOptions,\n  Server,\n  type WSMessage,\n  getServerByName,\n  routePartykitRequest\n} from \"partyserver\";\nimport { camelCaseToKebabCase } from \"./client\";\nimport { MCPClientManager, type MCPClientOAuthResult } from \"./mcp/client\";\nimport { MCPClientConnection } from \"./mcp/client-connection\";\nimport type { MCPConnectionState } from \"./mcp/client-connection\";\nimport { DurableObjectOAuthClientProvider } from \"./mcp/do-oauth-client-provider\";\nimport type { TransportType } from \"./mcp/types\";\nimport { genericObservability, type Observability } from \"./observability\";\nimport { DisposableStore } from \"./core/events\";\nimport { MessageType } from \"./ai-types\";\n\nexport type { Connection, ConnectionContext, WSMessage } from \"partyserver\";\n\n/**\n * RPC request message from client\n */\nexport type RPCRequest = {\n  type: \"rpc\";\n  id: string;\n  method: string;\n  args: unknown[];\n};\n\n/**\n * State update message from client\n */\nexport type StateUpdateMessage = {\n  type: MessageType.CF_AGENT_STATE;\n  state: unknown;\n};\n\n/**\n * RPC response message to client\n */\nexport type RPCResponse = {\n  type: MessageType.RPC;\n  id: string;\n} & (\n  | {\n      success: true;\n      result: unknown;\n      done?: false;\n    }\n  | {\n      success: true;\n      result: unknown;\n      done: true;\n    }\n  | {\n      success: false;\n      error: string;\n    }\n);\n\n/**\n * Type guard for RPC request messages\n */\nfunction isRPCRequest(msg: unknown): msg is RPCRequest {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === MessageType.RPC &&\n    \"id\" in msg &&\n    typeof msg.id === \"string\" &&\n    \"method\" in msg &&\n    typeof msg.method === \"string\" &&\n    \"args\" in msg &&\n    Array.isArray((msg as RPCRequest).args)\n  );\n}\n\n/**\n * Type guard for state update messages\n */\nfunction isStateUpdateMessage(msg: unknown): msg is StateUpdateMessage {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === MessageType.CF_AGENT_STATE &&\n    \"state\" in msg\n  );\n}\n\n/**\n * Metadata for a callable method\n */\nexport type CallableMetadata = {\n  /** Optional description of what the method does */\n  description?: string;\n  /** Whether the method supports streaming responses */\n  streaming?: boolean;\n};\n\nconst callableMetadata = new Map<Function, CallableMetadata>();\n\n/**\n * Decorator that marks a method as callable by clients\n * @param metadata Optional metadata about the callable method\n */\nexport function callable(metadata: CallableMetadata = {}) {\n  return function callableDecorator<This, Args extends unknown[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: later\n    context: ClassMethodDecoratorContext\n  ) {\n    if (!callableMetadata.has(target)) {\n      callableMetadata.set(target, metadata);\n    }\n\n    return target;\n  };\n}\n\nlet didWarnAboutUnstableCallable = false;\n\n/**\n * Decorator that marks a method as callable by clients\n * @deprecated this has been renamed to callable, and unstable_callable will be removed in the next major version\n * @param metadata Optional metadata about the callable method\n */\nexport const unstable_callable = (metadata: CallableMetadata = {}) => {\n  if (!didWarnAboutUnstableCallable) {\n    didWarnAboutUnstableCallable = true;\n    console.warn(\n      \"unstable_callable is deprecated, use callable instead. unstable_callable will be removed in the next major version.\"\n    );\n  }\n  callable(metadata);\n};\n\nexport type QueueItem<T = string> = {\n  id: string;\n  payload: T;\n  callback: keyof Agent<unknown>;\n  created_at: number;\n};\n\n/**\n * Represents a scheduled task within an Agent\n * @template T Type of the payload data\n */\nexport type Schedule<T = string> = {\n  /** Unique identifier for the schedule */\n  id: string;\n  /** Name of the method to be called */\n  callback: string;\n  /** Data to be passed to the callback */\n  payload: T;\n} & (\n  | {\n      /** Type of schedule for one-time execution at a specific time */\n      type: \"scheduled\";\n      /** Timestamp when the task should execute */\n      time: number;\n    }\n  | {\n      /** Type of schedule for delayed execution */\n      type: \"delayed\";\n      /** Timestamp when the task should execute */\n      time: number;\n      /** Number of seconds to delay execution */\n      delayInSeconds: number;\n    }\n  | {\n      /** Type of schedule for recurring execution based on cron expression */\n      type: \"cron\";\n      /** Timestamp for the next execution */\n      time: number;\n      /** Cron expression defining the schedule */\n      cron: string;\n    }\n);\n\nfunction getNextCronTime(cron: string) {\n  const interval = parseCronExpression(cron);\n  return interval.getNextDate();\n}\n\nexport type { TransportType } from \"./mcp/types\";\n\n/**\n * MCP Server state update message from server -> Client\n */\nexport type MCPServerMessage = {\n  type: MessageType.CF_AGENT_MCP_SERVERS;\n  mcp: MCPServersState;\n};\n\nexport type MCPServersState = {\n  servers: {\n    [id: string]: MCPServer;\n  };\n  tools: Tool[];\n  prompts: Prompt[];\n  resources: Resource[];\n};\n\nexport type MCPServer = {\n  name: string;\n  server_url: string;\n  auth_url: string | null;\n  // This state is specifically about the temporary process of getting a token (if needed).\n  // Scope outside of that can't be relied upon because when the DO sleeps, there's no way\n  // to communicate a change to a non-ready state.\n  state: MCPConnectionState;\n  instructions: string | null;\n  capabilities: ServerCapabilities | null;\n};\n\n/**\n * MCP Server data stored in DO SQL for resuming MCP Server connections\n */\ntype MCPServerRow = {\n  id: string;\n  name: string;\n  server_url: string;\n  client_id: string | null;\n  auth_url: string | null;\n  callback_url: string;\n  server_options: string;\n};\n\nconst STATE_ROW_ID = \"cf_state_row_id\";\nconst STATE_WAS_CHANGED = \"cf_state_was_changed\";\n\nconst DEFAULT_STATE = {} as unknown;\n\nconst agentContext = new AsyncLocalStorage<{\n  agent: Agent<unknown, unknown>;\n  connection: Connection | undefined;\n  request: Request | undefined;\n  email: AgentEmail | undefined;\n}>();\n\nexport function getCurrentAgent<\n  T extends Agent<unknown, unknown> = Agent<unknown, unknown>\n>(): {\n  agent: T | undefined;\n  connection: Connection | undefined;\n  request: Request | undefined;\n  email: AgentEmail | undefined;\n} {\n  const store = agentContext.getStore() as\n    | {\n        agent: T;\n        connection: Connection | undefined;\n        request: Request | undefined;\n        email: AgentEmail | undefined;\n      }\n    | undefined;\n  if (!store) {\n    return {\n      agent: undefined,\n      connection: undefined,\n      request: undefined,\n      email: undefined\n    };\n  }\n  return store;\n}\n\n/**\n * Wraps a method to run within the agent context, ensuring getCurrentAgent() works properly\n * @param agent The agent instance\n * @param method The method to wrap\n * @returns A wrapped method that runs within the agent context\n */\n\n// biome-ignore lint/suspicious/noExplicitAny: I can't typescript\nfunction withAgentContext<T extends (...args: any[]) => any>(\n  method: T\n): (this: Agent<unknown, unknown>, ...args: Parameters<T>) => ReturnType<T> {\n  return function (...args: Parameters<T>): ReturnType<T> {\n    const { connection, request, email, agent } = getCurrentAgent();\n\n    if (agent === this) {\n      // already wrapped, so we can just call the method\n      return method.apply(this, args);\n    }\n    // not wrapped, so we need to wrap it\n    return agentContext.run({ agent: this, connection, request, email }, () => {\n      return method.apply(this, args);\n    });\n  };\n}\n\n/**\n * Base class for creating Agent implementations\n * @template Env Environment type containing bindings\n * @template State State type to store within the Agent\n */\nexport class Agent<\n  Env = typeof env,\n  State = unknown,\n  Props extends Record<string, unknown> = Record<string, unknown>\n> extends Server<Env, Props> {\n  private _state = DEFAULT_STATE as State;\n  private _disposables = new DisposableStore();\n  private _mcpStateRestored = false;\n\n  private _ParentClass: typeof Agent<Env, State> =\n    Object.getPrototypeOf(this).constructor;\n\n  readonly mcp: MCPClientManager = new MCPClientManager(\n    this._ParentClass.name,\n    \"0.0.1\"\n  );\n\n  /**\n   * Initial state for the Agent\n   * Override to provide default state values\n   */\n  initialState: State = DEFAULT_STATE as State;\n\n  /**\n   * Current state of the Agent\n   */\n  get state(): State {\n    if (this._state !== DEFAULT_STATE) {\n      // state was previously set, and populated internal state\n      return this._state;\n    }\n    // looks like this is the first time the state is being accessed\n    // check if the state was set in a previous life\n    const wasChanged = this.sql<{ state: \"true\" | undefined }>`\n        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}\n      `;\n\n    // ok, let's pick up the actual state from the db\n    const result = this.sql<{ state: State | undefined }>`\n      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}\n    `;\n\n    if (\n      wasChanged[0]?.state === \"true\" ||\n      // we do this check for people who updated their code before we shipped wasChanged\n      result[0]?.state\n    ) {\n      const state = result[0]?.state as string; // could be null?\n\n      this._state = JSON.parse(state);\n      return this._state;\n    }\n\n    // ok, this is the first time the state is being accessed\n    // and the state was not set in a previous life\n    // so we need to set the initial state (if provided)\n    if (this.initialState === DEFAULT_STATE) {\n      // no initial state provided, so we return undefined\n      return undefined as State;\n    }\n    // initial state provided, so we set the state,\n    // update db and return the initial state\n    this.setState(this.initialState);\n    return this.initialState;\n  }\n\n  /**\n   * Agent configuration options\n   */\n  static options = {\n    /** Whether the Agent should hibernate when inactive */\n    hibernate: true // default to hibernate\n  };\n\n  /**\n   * The observability implementation to use for the Agent\n   */\n  observability?: Observability = genericObservability;\n\n  /**\n   * Execute SQL queries against the Agent's database\n   * @template T Type of the returned rows\n   * @param strings SQL query template strings\n   * @param values Values to be inserted into the query\n   * @returns Array of query results\n   */\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw this.onError(e);\n    }\n  }\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n\n    if (!wrappedClasses.has(this.constructor)) {\n      // Auto-wrap custom methods with agent context\n      this._autoWrapCustomMethods();\n      wrappedClasses.add(this.constructor);\n    }\n\n    // Broadcast server state after background connects (for OAuth servers)\n    this._disposables.add(\n      this.mcp.onConnected(async () => {\n        this.broadcastMcpServers();\n      })\n    );\n\n    // Emit MCP observability events\n    this._disposables.add(\n      this.mcp.onObservabilityEvent((event) => {\n        this.observability?.emit(event);\n      })\n    );\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_state (\n        id TEXT PRIMARY KEY NOT NULL,\n        state TEXT\n      )\n    `;\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_queues (\n        id TEXT PRIMARY KEY NOT NULL,\n        payload TEXT,\n        callback TEXT,\n        created_at INTEGER DEFAULT (unixepoch())\n      )\n    `;\n\n    void this.ctx.blockConcurrencyWhile(async () => {\n      return this._tryCatch(async () => {\n        // Create alarms table if it doesn't exist\n        this.sql`\n        CREATE TABLE IF NOT EXISTS cf_agents_schedules (\n          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),\n          callback TEXT,\n          payload TEXT,\n          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),\n          time INTEGER,\n          delayInSeconds INTEGER,\n          cron TEXT,\n          created_at INTEGER DEFAULT (unixepoch())\n        )\n      `;\n\n        // execute any pending alarms and schedule the next alarm\n        await this.alarm();\n      });\n    });\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (\n        id TEXT PRIMARY KEY NOT NULL,\n        name TEXT NOT NULL,\n        server_url TEXT NOT NULL,\n        callback_url TEXT NOT NULL,\n        client_id TEXT,\n        auth_url TEXT,\n        server_options TEXT\n      )\n    `;\n\n    const _onRequest = this.onRequest.bind(this);\n    this.onRequest = (request: Request) => {\n      return agentContext.run(\n        { agent: this, connection: undefined, request, email: undefined },\n        async () => {\n          await this._ensureMcpStateRestored();\n\n          if (this.mcp.isCallbackRequest(request)) {\n            const result = await this.mcp.handleCallbackRequest(request);\n            this.broadcastMcpServers();\n\n            if (result.authSuccess) {\n              this.clearMcpServerAuthUrl(result.serverId);\n\n              this.mcp\n                .establishConnection(result.serverId)\n                .catch((error) => {\n                  console.error(\"Background connection failed:\", error);\n                })\n                .finally(() => {\n                  this.broadcastMcpServers();\n                });\n            }\n\n            return this.handleOAuthCallbackResponse(result, request);\n          }\n\n          return this._tryCatch(() => _onRequest(request));\n        }\n      );\n    };\n\n    const _onMessage = this.onMessage.bind(this);\n    this.onMessage = async (connection: Connection, message: WSMessage) => {\n      return agentContext.run(\n        { agent: this, connection, request: undefined, email: undefined },\n        async () => {\n          if (typeof message !== \"string\") {\n            return this._tryCatch(() => _onMessage(connection, message));\n          }\n\n          let parsed: unknown;\n          try {\n            parsed = JSON.parse(message);\n          } catch (_e) {\n            // silently fail and let the onMessage handler handle it\n            return this._tryCatch(() => _onMessage(connection, message));\n          }\n\n          if (isStateUpdateMessage(parsed)) {\n            this._setStateInternal(parsed.state as State, connection);\n            return;\n          }\n\n          if (isRPCRequest(parsed)) {\n            try {\n              const { id, method, args } = parsed;\n\n              // Check if method exists and is callable\n              const methodFn = this[method as keyof this];\n              if (typeof methodFn !== \"function\") {\n                throw new Error(`Method ${method} does not exist`);\n              }\n\n              if (!this._isCallable(method)) {\n                throw new Error(`Method ${method} is not callable`);\n              }\n\n              const metadata = callableMetadata.get(methodFn as Function);\n\n              // For streaming methods, pass a StreamingResponse object\n              if (metadata?.streaming) {\n                const stream = new StreamingResponse(connection, id);\n                await methodFn.apply(this, [stream, ...args]);\n                return;\n              }\n\n              // For regular methods, execute and send response\n              const result = await methodFn.apply(this, args);\n\n              this.observability?.emit(\n                {\n                  displayMessage: `RPC call to ${method}`,\n                  id: nanoid(),\n                  payload: {\n                    method,\n                    streaming: metadata?.streaming\n                  },\n                  timestamp: Date.now(),\n                  type: \"rpc\"\n                },\n                this.ctx\n              );\n\n              const response: RPCResponse = {\n                done: true,\n                id,\n                result,\n                success: true,\n                type: MessageType.RPC\n              };\n              connection.send(JSON.stringify(response));\n            } catch (e) {\n              // Send error response\n              const response: RPCResponse = {\n                error:\n                  e instanceof Error ? e.message : \"Unknown error occurred\",\n                id: parsed.id,\n                success: false,\n                type: MessageType.RPC\n              };\n              connection.send(JSON.stringify(response));\n              console.error(\"RPC error:\", e);\n            }\n            return;\n          }\n\n          return this._tryCatch(() => _onMessage(connection, message));\n        }\n      );\n    };\n\n    const _onConnect = this.onConnect.bind(this);\n    this.onConnect = (connection: Connection, ctx: ConnectionContext) => {\n      // TODO: This is a hack to ensure the state is sent after the connection is established\n      // must fix this\n      return agentContext.run(\n        { agent: this, connection, request: ctx.request, email: undefined },\n        () => {\n          if (this.state) {\n            connection.send(\n              JSON.stringify({\n                state: this.state,\n                type: MessageType.CF_AGENT_STATE\n              })\n            );\n          }\n\n          connection.send(\n            JSON.stringify({\n              mcp: this.getMcpServers(),\n              type: MessageType.CF_AGENT_MCP_SERVERS\n            })\n          );\n\n          this.observability?.emit(\n            {\n              displayMessage: \"Connection established\",\n              id: nanoid(),\n              payload: {\n                connectionId: connection.id\n              },\n              timestamp: Date.now(),\n              type: \"connect\"\n            },\n            this.ctx\n          );\n          return this._tryCatch(() => _onConnect(connection, ctx));\n        }\n      );\n    };\n\n    const _onStart = this.onStart.bind(this);\n    this.onStart = async (props?: Props) => {\n      return agentContext.run(\n        {\n          agent: this,\n          connection: undefined,\n          request: undefined,\n          email: undefined\n        },\n        async () => {\n          await this._tryCatch(async () => {\n            await this._ensureMcpStateRestored();\n            this.broadcastMcpServers();\n            return _onStart(props);\n          });\n        }\n      );\n    };\n  }\n\n  private _setStateInternal(\n    state: State,\n    source: Connection | \"server\" = \"server\"\n  ) {\n    this._state = state;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})\n  `;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})\n  `;\n    this.broadcast(\n      JSON.stringify({\n        state: state,\n        type: MessageType.CF_AGENT_STATE\n      }),\n      source !== \"server\" ? [source.id] : []\n    );\n    return this._tryCatch(() => {\n      const { connection, request, email } = agentContext.getStore() || {};\n      return agentContext.run(\n        { agent: this, connection, request, email },\n        async () => {\n          this.observability?.emit(\n            {\n              displayMessage: \"State updated\",\n              id: nanoid(),\n              payload: {},\n              timestamp: Date.now(),\n              type: \"state:update\"\n            },\n            this.ctx\n          );\n          return this.onStateUpdate(state, source);\n        }\n      );\n    });\n  }\n\n  /**\n   * Update the Agent's state\n   * @param state New state to set\n   */\n  setState(state: State) {\n    this._setStateInternal(state, \"server\");\n  }\n\n  /**\n   * Called when the Agent's state is updated\n   * @param state Updated state\n   * @param source Source of the state update (\"server\" or a client connection)\n   */\n  // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    // override this to handle state updates\n  }\n\n  /**\n   * Called when the Agent receives an email via routeAgentEmail()\n   * Override this method to handle incoming emails\n   * @param email Email message to process\n   */\n  async _onEmail(email: AgentEmail) {\n    // nb: we use this roundabout way of getting to onEmail\n    // because of https://github.com/cloudflare/workerd/issues/4499\n    return agentContext.run(\n      { agent: this, connection: undefined, request: undefined, email: email },\n      async () => {\n        if (\"onEmail\" in this && typeof this.onEmail === \"function\") {\n          return this._tryCatch(() =>\n            (this.onEmail as (email: AgentEmail) => Promise<void>)(email)\n          );\n        } else {\n          console.log(\"Received email from:\", email.from, \"to:\", email.to);\n          console.log(\"Subject:\", email.headers.get(\"subject\"));\n          console.log(\n            \"Implement onEmail(email: AgentEmail): Promise<void> in your agent to process emails\"\n          );\n        }\n      }\n    );\n  }\n\n  /**\n   * Reply to an email\n   * @param email The email to reply to\n   * @param options Options for the reply\n   * @returns void\n   */\n  async replyToEmail(\n    email: AgentEmail,\n    options: {\n      fromName: string;\n      subject?: string | undefined;\n      body: string;\n      contentType?: string;\n      headers?: Record<string, string>;\n    }\n  ): Promise<void> {\n    return this._tryCatch(async () => {\n      const agentName = camelCaseToKebabCase(this._ParentClass.name);\n      const agentId = this.name;\n\n      const { createMimeMessage } = await import(\"mimetext\");\n      const msg = createMimeMessage();\n      msg.setSender({ addr: email.to, name: options.fromName });\n      msg.setRecipient(email.from);\n      msg.setSubject(\n        options.subject || `Re: ${email.headers.get(\"subject\")}` || \"No subject\"\n      );\n      msg.addMessage({\n        contentType: options.contentType || \"text/plain\",\n        data: options.body\n      });\n\n      const domain = email.from.split(\"@\")[1];\n      const messageId = `<${agentId}@${domain}>`;\n      msg.setHeader(\"In-Reply-To\", email.headers.get(\"Message-ID\")!);\n      msg.setHeader(\"Message-ID\", messageId);\n      msg.setHeader(\"X-Agent-Name\", agentName);\n      msg.setHeader(\"X-Agent-ID\", agentId);\n\n      if (options.headers) {\n        for (const [key, value] of Object.entries(options.headers)) {\n          msg.setHeader(key, value);\n        }\n      }\n      await email.reply({\n        from: email.to,\n        raw: msg.asRaw(),\n        to: email.from\n      });\n    });\n  }\n\n  private async _tryCatch<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  /**\n   * Automatically wrap custom methods with agent context\n   * This ensures getCurrentAgent() works in all custom methods without decorators\n   */\n  private _autoWrapCustomMethods() {\n    // Collect all methods from base prototypes (Agent and Server)\n    const basePrototypes = [Agent.prototype, Server.prototype];\n    const baseMethods = new Set<string>();\n    for (const baseProto of basePrototypes) {\n      let proto = baseProto;\n      while (proto && proto !== Object.prototype) {\n        const methodNames = Object.getOwnPropertyNames(proto);\n        for (const methodName of methodNames) {\n          baseMethods.add(methodName);\n        }\n        proto = Object.getPrototypeOf(proto);\n      }\n    }\n    // Get all methods from the current instance's prototype chain\n    let proto = Object.getPrototypeOf(this);\n    let depth = 0;\n    while (proto && proto !== Object.prototype && depth < 10) {\n      const methodNames = Object.getOwnPropertyNames(proto);\n      for (const methodName of methodNames) {\n        const descriptor = Object.getOwnPropertyDescriptor(proto, methodName);\n\n        // Skip if it's a private method, a base method, a getter, or not a function,\n        if (\n          baseMethods.has(methodName) ||\n          methodName.startsWith(\"_\") ||\n          !descriptor ||\n          !!descriptor.get ||\n          typeof descriptor.value !== \"function\"\n        ) {\n          continue;\n        }\n\n        // Now, methodName is confirmed to be a custom method/function\n        // Wrap the custom method with context\n        const wrappedFunction = withAgentContext(\n          // biome-ignore lint/suspicious/noExplicitAny: I can't typescript\n          this[methodName as keyof this] as (...args: any[]) => any\n          // biome-ignore lint/suspicious/noExplicitAny: I can't typescript\n        ) as any;\n\n        // if the method is callable, copy the metadata from the original method\n        if (this._isCallable(methodName)) {\n          callableMetadata.set(\n            wrappedFunction,\n            callableMetadata.get(this[methodName as keyof this] as Function)!\n          );\n        }\n\n        // set the wrapped function on the prototype\n        this.constructor.prototype[methodName as keyof this] = wrappedFunction;\n      }\n\n      proto = Object.getPrototypeOf(proto);\n      depth++;\n    }\n  }\n\n  override onError(\n    connection: Connection,\n    error: unknown\n  ): void | Promise<void>;\n  override onError(error: unknown): void | Promise<void>;\n  override onError(connectionOrError: Connection | unknown, error?: unknown) {\n    let theError: unknown;\n    if (connectionOrError && error) {\n      theError = error;\n      // this is a websocket connection error\n      console.error(\n        \"Error on websocket connection:\",\n        (connectionOrError as Connection).id,\n        theError\n      );\n      console.error(\n        \"Override onError(connection, error) to handle websocket connection errors\"\n      );\n    } else {\n      theError = connectionOrError;\n      // this is a server error\n      console.error(\"Error on server:\", theError);\n      console.error(\"Override onError(error) to handle server errors\");\n    }\n    throw theError;\n  }\n\n  /**\n   * Render content (not implemented in base class)\n   */\n  render() {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Queue a task to be executed in the future\n   * @param payload Payload to pass to the callback\n   * @param callback Name of the method to call\n   * @returns The ID of the queued task\n   */\n  async queue<T = unknown>(callback: keyof this, payload: T): Promise<string> {\n    const id = nanoid(9);\n    if (typeof callback !== \"string\") {\n      throw new Error(\"Callback must be a string\");\n    }\n\n    if (typeof this[callback] !== \"function\") {\n      throw new Error(`this.${callback} is not a function`);\n    }\n\n    this.sql`\n      INSERT OR REPLACE INTO cf_agents_queues (id, payload, callback)\n      VALUES (${id}, ${JSON.stringify(payload)}, ${callback})\n    `;\n\n    void this._flushQueue().catch((e) => {\n      console.error(\"Error flushing queue:\", e);\n    });\n\n    return id;\n  }\n\n  private _flushingQueue = false;\n\n  private async _flushQueue() {\n    if (this._flushingQueue) {\n      return;\n    }\n    this._flushingQueue = true;\n    while (true) {\n      const result = this.sql<QueueItem<string>>`\n      SELECT * FROM cf_agents_queues\n      ORDER BY created_at ASC\n    `;\n\n      if (!result || result.length === 0) {\n        break;\n      }\n\n      for (const row of result || []) {\n        const callback = this[row.callback as keyof Agent<Env>];\n        if (!callback) {\n          console.error(`callback ${row.callback} not found`);\n          continue;\n        }\n        const { connection, request, email } = agentContext.getStore() || {};\n        await agentContext.run(\n          {\n            agent: this,\n            connection,\n            request,\n            email\n          },\n          async () => {\n            // TODO: add retries and backoff\n            await (\n              callback as (\n                payload: unknown,\n                queueItem: QueueItem<string>\n              ) => Promise<void>\n            ).bind(this)(JSON.parse(row.payload as string), row);\n            await this.dequeue(row.id);\n          }\n        );\n      }\n    }\n    this._flushingQueue = false;\n  }\n\n  /**\n   * Dequeue a task by ID\n   * @param id ID of the task to dequeue\n   */\n  async dequeue(id: string) {\n    this.sql`DELETE FROM cf_agents_queues WHERE id = ${id}`;\n  }\n\n  /**\n   * Dequeue all tasks\n   */\n  async dequeueAll() {\n    this.sql`DELETE FROM cf_agents_queues`;\n  }\n\n  /**\n   * Dequeue all tasks by callback\n   * @param callback Name of the callback to dequeue\n   */\n  async dequeueAllByCallback(callback: string) {\n    this.sql`DELETE FROM cf_agents_queues WHERE callback = ${callback}`;\n  }\n\n  /**\n   * Get a queued task by ID\n   * @param id ID of the task to get\n   * @returns The task or undefined if not found\n   */\n  async getQueue(id: string): Promise<QueueItem<string> | undefined> {\n    const result = this.sql<QueueItem<string>>`\n      SELECT * FROM cf_agents_queues WHERE id = ${id}\n    `;\n    return result\n      ? { ...result[0], payload: JSON.parse(result[0].payload) }\n      : undefined;\n  }\n\n  /**\n   * Get all queues by key and value\n   * @param key Key to filter by\n   * @param value Value to filter by\n   * @returns Array of matching QueueItem objects\n   */\n  async getQueues(key: string, value: string): Promise<QueueItem<string>[]> {\n    const result = this.sql<QueueItem<string>>`\n      SELECT * FROM cf_agents_queues\n    `;\n    return result.filter((row) => JSON.parse(row.payload)[key] === value);\n  }\n\n  /**\n   * Schedule a task to be executed in the future\n   * @template T Type of the payload data\n   * @param when When to execute the task (Date, seconds delay, or cron expression)\n   * @param callback Name of the method to call\n   * @param payload Data to pass to the callback\n   * @returns Schedule object representing the scheduled task\n   */\n  async schedule<T = string>(\n    when: Date | string | number,\n    callback: keyof this,\n    payload?: T\n  ): Promise<Schedule<T>> {\n    const id = nanoid(9);\n\n    const emitScheduleCreate = (schedule: Schedule<T>) =>\n      this.observability?.emit(\n        {\n          displayMessage: `Schedule ${schedule.id} created`,\n          id: nanoid(),\n          payload: {\n            callback: callback as string,\n            id: id\n          },\n          timestamp: Date.now(),\n          type: \"schedule:create\"\n        },\n        this.ctx\n      );\n\n    if (typeof callback !== \"string\") {\n      throw new Error(\"Callback must be a string\");\n    }\n\n    if (typeof this[callback] !== \"function\") {\n      throw new Error(`this.${callback} is not a function`);\n    }\n\n    if (when instanceof Date) {\n      const timestamp = Math.floor(when.getTime() / 1000);\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'scheduled', ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      const schedule: Schedule<T> = {\n        callback: callback,\n        id,\n        payload: payload as T,\n        time: timestamp,\n        type: \"scheduled\"\n      };\n\n      emitScheduleCreate(schedule);\n\n      return schedule;\n    }\n    if (typeof when === \"number\") {\n      const time = new Date(Date.now() + when * 1000);\n      const timestamp = Math.floor(time.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'delayed', ${when}, ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      const schedule: Schedule<T> = {\n        callback: callback,\n        delayInSeconds: when,\n        id,\n        payload: payload as T,\n        time: timestamp,\n        type: \"delayed\"\n      };\n\n      emitScheduleCreate(schedule);\n\n      return schedule;\n    }\n    if (typeof when === \"string\") {\n      const nextExecutionTime = getNextCronTime(when);\n      const timestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'cron', ${when}, ${timestamp})\n      `;\n\n      await this._scheduleNextAlarm();\n\n      const schedule: Schedule<T> = {\n        callback: callback,\n        cron: when,\n        id,\n        payload: payload as T,\n        time: timestamp,\n        type: \"cron\"\n      };\n\n      emitScheduleCreate(schedule);\n\n      return schedule;\n    }\n    throw new Error(\"Invalid schedule type\");\n  }\n\n  /**\n   * Get a scheduled task by ID\n   * @template T Type of the payload data\n   * @param id ID of the scheduled task\n   * @returns The Schedule object or undefined if not found\n   */\n  async getSchedule<T = string>(id: string): Promise<Schedule<T> | undefined> {\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE id = ${id}\n    `;\n    if (!result) {\n      console.error(`schedule ${id} not found`);\n      return undefined;\n    }\n\n    return { ...result[0], payload: JSON.parse(result[0].payload) as T };\n  }\n\n  /**\n   * Get scheduled tasks matching the given criteria\n   * @template T Type of the payload data\n   * @param criteria Criteria to filter schedules\n   * @returns Array of matching Schedule objects\n   */\n  getSchedules<T = string>(\n    criteria: {\n      id?: string;\n      type?: \"scheduled\" | \"delayed\" | \"cron\";\n      timeRange?: { start?: Date; end?: Date };\n    } = {}\n  ): Schedule<T>[] {\n    let query = \"SELECT * FROM cf_agents_schedules WHERE 1=1\";\n    const params = [];\n\n    if (criteria.id) {\n      query += \" AND id = ?\";\n      params.push(criteria.id);\n    }\n\n    if (criteria.type) {\n      query += \" AND type = ?\";\n      params.push(criteria.type);\n    }\n\n    if (criteria.timeRange) {\n      query += \" AND time >= ? AND time <= ?\";\n      const start = criteria.timeRange.start || new Date(0);\n      const end = criteria.timeRange.end || new Date(999999999999999);\n      params.push(\n        Math.floor(start.getTime() / 1000),\n        Math.floor(end.getTime() / 1000)\n      );\n    }\n\n    const result = this.ctx.storage.sql\n      .exec(query, ...params)\n      .toArray()\n      .map((row) => ({\n        ...row,\n        payload: JSON.parse(row.payload as string) as T\n      })) as Schedule<T>[];\n\n    return result;\n  }\n\n  /**\n   * Cancel a scheduled task\n   * @param id ID of the task to cancel\n   * @returns true if the task was cancelled, false otherwise\n   */\n  async cancelSchedule(id: string): Promise<boolean> {\n    const schedule = await this.getSchedule(id);\n    if (schedule) {\n      this.observability?.emit(\n        {\n          displayMessage: `Schedule ${id} cancelled`,\n          id: nanoid(),\n          payload: {\n            callback: schedule.callback,\n            id: schedule.id\n          },\n          timestamp: Date.now(),\n          type: \"schedule:cancel\"\n        },\n        this.ctx\n      );\n    }\n    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;\n\n    await this._scheduleNextAlarm();\n    return true;\n  }\n\n  private async _scheduleNextAlarm() {\n    // Find the next schedule that needs to be executed\n    const result = this.sql`\n      SELECT time FROM cf_agents_schedules\n      WHERE time > ${Math.floor(Date.now() / 1000)}\n      ORDER BY time ASC\n      LIMIT 1\n    `;\n    if (!result) return;\n\n    if (result.length > 0 && \"time\" in result[0]) {\n      const nextTime = (result[0].time as number) * 1000;\n      await this.ctx.storage.setAlarm(nextTime);\n    }\n  }\n\n  /**\n   * Method called when an alarm fires.\n   * Executes any scheduled tasks that are due.\n   *\n   * @remarks\n   * To schedule a task, please use the `this.schedule` method instead.\n   * See {@link https://developers.cloudflare.com/agents/api-reference/schedule-tasks/}\n   */\n  public readonly alarm = async () => {\n    const now = Math.floor(Date.now() / 1000);\n\n    // Get all schedules that should be executed now\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE time <= ${now}\n    `;\n\n    if (result && Array.isArray(result)) {\n      for (const row of result) {\n        const callback = this[row.callback as keyof Agent<Env>];\n        if (!callback) {\n          console.error(`callback ${row.callback} not found`);\n          continue;\n        }\n        await agentContext.run(\n          {\n            agent: this,\n            connection: undefined,\n            request: undefined,\n            email: undefined\n          },\n          async () => {\n            try {\n              this.observability?.emit(\n                {\n                  displayMessage: `Schedule ${row.id} executed`,\n                  id: nanoid(),\n                  payload: {\n                    callback: row.callback,\n                    id: row.id\n                  },\n                  timestamp: Date.now(),\n                  type: \"schedule:execute\"\n                },\n                this.ctx\n              );\n\n              await (\n                callback as (\n                  payload: unknown,\n                  schedule: Schedule<unknown>\n                ) => Promise<void>\n              ).bind(this)(JSON.parse(row.payload as string), row);\n            } catch (e) {\n              console.error(`error executing callback \"${row.callback}\"`, e);\n            }\n          }\n        );\n        if (row.type === \"cron\") {\n          // Update next execution time for cron schedules\n          const nextExecutionTime = getNextCronTime(row.cron);\n          const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n          this.sql`\n          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}\n        `;\n        } else {\n          // Delete one-time schedules after execution\n          this.sql`\n          DELETE FROM cf_agents_schedules WHERE id = ${row.id}\n        `;\n        }\n      }\n    }\n\n    // Schedule the next alarm\n    await this._scheduleNextAlarm();\n  };\n\n  /**\n   * Destroy the Agent, removing all state and scheduled tasks\n   */\n  async destroy() {\n    // drop all tables\n    this.sql`DROP TABLE IF EXISTS cf_agents_state`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_queues`;\n\n    // delete all alarms\n    await this.ctx.storage.deleteAlarm();\n    await this.ctx.storage.deleteAll();\n    this._disposables.dispose();\n    await this.mcp.dispose?.();\n    this.ctx.abort(\"destroyed\"); // enforce that the agent is evicted\n\n    this.observability?.emit(\n      {\n        displayMessage: \"Agent destroyed\",\n        id: nanoid(),\n        payload: {},\n        timestamp: Date.now(),\n        type: \"destroy\"\n      },\n      this.ctx\n    );\n  }\n\n  /**\n   * Get all methods marked as callable on this Agent\n   * @returns A map of method names to their metadata\n   */\n  private _isCallable(method: string): boolean {\n    return callableMetadata.has(this[method as keyof this] as Function);\n  }\n\n  private async _ensureMcpStateRestored() {\n    if (this._mcpStateRestored) {\n      return;\n    }\n\n    this._mcpStateRestored = true;\n\n    const servers = this.sql<MCPServerRow>`\n        SELECT id, name, server_url, client_id, auth_url, callback_url, server_options\n        FROM cf_agents_mcp_servers\n      `;\n\n    if (!servers || !Array.isArray(servers) || servers.length === 0) {\n      return;\n    }\n\n    for (const server of servers) {\n      if (server.callback_url) {\n        this.mcp.registerCallbackUrl(`${server.callback_url}/${server.id}`);\n      }\n    }\n\n    for (const server of servers) {\n      const needsOAuth = !!server.auth_url;\n\n      if (needsOAuth) {\n        const authProvider = new DurableObjectOAuthClientProvider(\n          this.ctx.storage,\n          this.name,\n          server.callback_url\n        );\n        authProvider.serverId = server.id;\n        if (server.client_id) {\n          authProvider.clientId = server.client_id;\n        }\n\n        const parsedOptions = server.server_options\n          ? JSON.parse(server.server_options)\n          : undefined;\n\n        const conn = new MCPClientConnection(\n          new URL(server.server_url),\n          {\n            name: this.name,\n            version: \"1.0.0\"\n          },\n          {\n            client: parsedOptions?.client ?? {},\n            transport: {\n              ...(parsedOptions?.transport ?? {}),\n              type: parsedOptions?.transport?.type ?? (\"auto\" as TransportType),\n              authProvider\n            }\n          }\n        );\n\n        conn.connectionState = \"authenticating\";\n        this.mcp.mcpConnections[server.id] = conn;\n      } else {\n        const parsedOptions = server.server_options\n          ? JSON.parse(server.server_options)\n          : undefined;\n\n        this._connectToMcpServerInternal(\n          server.name,\n          server.server_url,\n          server.callback_url,\n          parsedOptions,\n          {\n            id: server.id,\n            oauthClientId: server.client_id ?? undefined\n          }\n        ).catch((error) => {\n          console.error(`Error restoring ${server.id}:`, error);\n        });\n      }\n    }\n  }\n\n  /**\n   * Connect to a new MCP Server\n   *\n   * @param serverName Name of the MCP server\n   * @param url MCP Server SSE URL\n   * @param callbackHost Base host for the agent, used for the redirect URI. If not provided, will be derived from the current request.\n   * @param agentsPrefix agents routing prefix if not using `agents`\n   * @param options MCP client and transport options\n   * @returns authUrl\n   */\n  async addMcpServer(\n    serverName: string,\n    url: string,\n    callbackHost?: string,\n    agentsPrefix = \"agents\",\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      transport?: {\n        headers?: HeadersInit;\n        type?: TransportType;\n      };\n    }\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    // If callbackHost is not provided, derive it from the current request\n    let resolvedCallbackHost = callbackHost;\n    if (!resolvedCallbackHost) {\n      const { request } = getCurrentAgent();\n      if (!request) {\n        throw new Error(\n          \"callbackHost is required when not called within a request context\"\n        );\n      }\n\n      // Extract the origin from the request\n      const requestUrl = new URL(request.url);\n      resolvedCallbackHost = `${requestUrl.protocol}//${requestUrl.host}`;\n    }\n\n    const callbackUrl = `${resolvedCallbackHost}/${agentsPrefix}/${camelCaseToKebabCase(this._ParentClass.name)}/${this.name}/callback`;\n\n    const result = await this._connectToMcpServerInternal(\n      serverName,\n      url,\n      callbackUrl,\n      options\n    );\n\n    this.sql`\n        INSERT\n        OR REPLACE INTO cf_agents_mcp_servers (id, name, server_url, client_id, auth_url, callback_url, server_options)\n      VALUES (\n        ${result.id},\n        ${serverName},\n        ${url},\n        ${result.clientId ?? null},\n        ${result.authUrl ?? null},\n        ${callbackUrl},\n        ${options ? JSON.stringify(options) : null}\n        );\n    `;\n\n    this.broadcastMcpServers();\n\n    return result;\n  }\n\n  private async _connectToMcpServerInternal(\n    _serverName: string,\n    url: string,\n    callbackUrl: string,\n    // it's important that any options here are serializable because we put them into our sqlite DB for reconnection purposes\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      /**\n       * We don't expose the normal set of transport options because:\n       * 1) we can't serialize things like the auth provider or a fetch function into the DB for reconnection purposes\n       * 2) We probably want these options to be agnostic to the transport type (SSE vs Streamable)\n       *\n       * This has the limitation that you can't override fetch, but I think headers should handle nearly all cases needed (i.e. non-standard bearer auth).\n       */\n      transport?: {\n        headers?: HeadersInit;\n        type?: TransportType;\n      };\n    },\n    reconnect?: {\n      id: string;\n      oauthClientId?: string;\n    }\n  ): Promise<{\n    id: string;\n    authUrl: string | undefined;\n    clientId: string | undefined;\n  }> {\n    const authProvider = new DurableObjectOAuthClientProvider(\n      this.ctx.storage,\n      this.name,\n      callbackUrl\n    );\n\n    if (reconnect) {\n      authProvider.serverId = reconnect.id;\n      if (reconnect.oauthClientId) {\n        authProvider.clientId = reconnect.oauthClientId;\n      }\n    }\n\n    // Use the transport type specified in options, or default to \"auto\"\n    const transportType: TransportType = options?.transport?.type ?? \"auto\";\n\n    // allows passing through transport headers if necessary\n    // this handles some non-standard bearer auth setups (i.e. MCP server behind CF access instead of OAuth)\n    let headerTransportOpts: SSEClientTransportOptions = {};\n    if (options?.transport?.headers) {\n      headerTransportOpts = {\n        eventSourceInit: {\n          fetch: (url, init) =>\n            fetch(url, {\n              ...init,\n              headers: options?.transport?.headers\n            })\n        },\n        requestInit: {\n          headers: options?.transport?.headers\n        }\n      };\n    }\n\n    const { id, authUrl, clientId } = await this.mcp.connect(url, {\n      client: options?.client,\n      reconnect,\n      transport: {\n        ...headerTransportOpts,\n        authProvider,\n        type: transportType\n      }\n    });\n\n    return {\n      authUrl,\n      clientId,\n      id\n    };\n  }\n\n  async removeMcpServer(id: string) {\n    this.mcp.closeConnection(id);\n    this.mcp.unregisterCallbackUrl(id);\n    this.sql`\n      DELETE FROM cf_agents_mcp_servers WHERE id = ${id};\n    `;\n    this.broadcastMcpServers();\n  }\n\n  /**\n   * Clear the auth_url for an MCP server after successful OAuth authentication\n   * This prevents the agent from continuously asking for OAuth on reconnect\n   * @param id The server ID to clear auth_url for\n   */\n  private clearMcpServerAuthUrl(id: string) {\n    this.sql`\n      UPDATE cf_agents_mcp_servers\n      SET auth_url = NULL\n      WHERE id = ${id}\n    `;\n  }\n\n  getMcpServers(): MCPServersState {\n    const mcpState: MCPServersState = {\n      prompts: this.mcp.listPrompts(),\n      resources: this.mcp.listResources(),\n      servers: {},\n      tools: this.mcp.listTools()\n    };\n\n    const servers = this.sql<MCPServerRow>`\n      SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n    `;\n\n    if (servers && Array.isArray(servers) && servers.length > 0) {\n      for (const server of servers) {\n        const serverConn = this.mcp.mcpConnections[server.id];\n        mcpState.servers[server.id] = {\n          auth_url: server.auth_url,\n          capabilities: serverConn?.serverCapabilities ?? null,\n          instructions: serverConn?.instructions ?? null,\n          name: server.name,\n          server_url: server.server_url,\n          // mark as \"authenticating\" because the server isn't automatically connected, so it's pending authenticating\n          state: serverConn?.connectionState ?? \"authenticating\"\n        };\n      }\n    }\n\n    return mcpState;\n  }\n\n  private broadcastMcpServers() {\n    this.broadcast(\n      JSON.stringify({\n        mcp: this.getMcpServers(),\n        type: MessageType.CF_AGENT_MCP_SERVERS\n      })\n    );\n  }\n\n  /**\n   * Handle OAuth callback response using MCPClientManager configuration\n   * @param result OAuth callback result\n   * @param request The original request (needed for base URL)\n   * @returns Response for the OAuth callback\n   */\n  private handleOAuthCallbackResponse(\n    result: MCPClientOAuthResult,\n    request: Request\n  ): Response {\n    const config = this.mcp.getOAuthCallbackConfig();\n\n    // Use custom handler if configured\n    if (config?.customHandler) {\n      return config.customHandler(result);\n    }\n\n    const baseOrigin = new URL(request.url).origin;\n\n    // Redirect to success URL if configured\n    if (config?.successRedirect && result.authSuccess) {\n      try {\n        return Response.redirect(\n          new URL(config.successRedirect, baseOrigin).href\n        );\n      } catch (e) {\n        console.error(\n          \"Invalid successRedirect URL:\",\n          config.successRedirect,\n          e\n        );\n        return Response.redirect(baseOrigin);\n      }\n    }\n\n    // Redirect to error URL if configured\n    if (config?.errorRedirect && !result.authSuccess) {\n      try {\n        const errorUrl = `${config.errorRedirect}?error=${encodeURIComponent(\n          result.authError || \"Unknown error\"\n        )}`;\n        return Response.redirect(new URL(errorUrl, baseOrigin).href);\n      } catch (e) {\n        console.error(\"Invalid errorRedirect URL:\", config.errorRedirect, e);\n        return Response.redirect(baseOrigin);\n      }\n    }\n\n    // Default: redirect to base URL\n    return Response.redirect(baseOrigin);\n  }\n}\n\n// A set of classes that have been wrapped with agent context\nconst wrappedClasses = new Set<typeof Agent.prototype.constructor>();\n\n/**\n * Namespace for creating Agent instances\n * @template Agentic Type of the Agent class\n */\nexport type AgentNamespace<Agentic extends Agent<unknown>> =\n  DurableObjectNamespace<Agentic>;\n\n/**\n * Agent's durable context\n */\nexport type AgentContext = DurableObjectState;\n\n/**\n * Configuration options for Agent routing\n */\nexport type AgentOptions<Env> = PartyServerOptions<Env> & {\n  /**\n   * Whether to enable CORS for the Agent\n   */\n  cors?: boolean | HeadersInit | undefined;\n};\n\n/**\n * Route a request to the appropriate Agent\n * @param request Request to route\n * @param env Environment containing Agent bindings\n * @param options Routing options\n * @returns Response from the Agent or undefined if no route matched\n */\nexport async function routeAgentRequest<Env>(\n  request: Request,\n  env: Env,\n  options?: AgentOptions<Env>\n) {\n  const corsHeaders =\n    options?.cors === true\n      ? {\n          \"Access-Control-Allow-Credentials\": \"true\",\n          \"Access-Control-Allow-Methods\": \"GET, POST, HEAD, OPTIONS\",\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Max-Age\": \"86400\"\n        }\n      : options?.cors;\n\n  if (request.method === \"OPTIONS\") {\n    if (corsHeaders) {\n      return new Response(null, {\n        headers: corsHeaders\n      });\n    }\n    console.warn(\n      \"Received an OPTIONS request, but cors was not enabled. Pass `cors: true` or `cors: { ...custom cors headers }` to routeAgentRequest to enable CORS.\"\n    );\n  }\n\n  let response = await routePartykitRequest(\n    request,\n    env as Record<string, unknown>,\n    {\n      prefix: \"agents\",\n      ...(options as PartyServerOptions<Record<string, unknown>>)\n    }\n  );\n\n  if (\n    response &&\n    corsHeaders &&\n    request.headers.get(\"upgrade\")?.toLowerCase() !== \"websocket\" &&\n    request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\"\n  ) {\n    const newHeaders = new Headers(response.headers);\n\n    // Add CORS headers\n    for (const [key, value] of Object.entries(corsHeaders)) {\n      newHeaders.set(key, value);\n    }\n\n    response = new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: newHeaders\n    });\n  }\n  return response;\n}\n\nexport type EmailResolver<Env> = (\n  email: ForwardableEmailMessage,\n  env: Env\n) => Promise<{\n  agentName: string;\n  agentId: string;\n} | null>;\n\n/**\n * Create a resolver that uses the message-id header to determine the agent to route the email to\n * @returns A function that resolves the agent to route the email to\n */\nexport function createHeaderBasedEmailResolver<Env>(): EmailResolver<Env> {\n  return async (email: ForwardableEmailMessage, _env: Env) => {\n    const messageId = email.headers.get(\"message-id\");\n    if (messageId) {\n      const messageIdMatch = messageId.match(/<([^@]+)@([^>]+)>/);\n      if (messageIdMatch) {\n        const [, agentId, domain] = messageIdMatch;\n        const agentName = domain.split(\".\")[0];\n        return { agentName, agentId };\n      }\n    }\n\n    const references = email.headers.get(\"references\");\n    if (references) {\n      const referencesMatch = references.match(\n        /<([A-Za-z0-9+/]{43}=)@([^>]+)>/\n      );\n      if (referencesMatch) {\n        const [, base64Id, domain] = referencesMatch;\n        const agentId = Buffer.from(base64Id, \"base64\").toString(\"hex\");\n        const agentName = domain.split(\".\")[0];\n        return { agentName, agentId };\n      }\n    }\n\n    const agentName = email.headers.get(\"x-agent-name\");\n    const agentId = email.headers.get(\"x-agent-id\");\n    if (agentName && agentId) {\n      return { agentName, agentId };\n    }\n\n    return null;\n  };\n}\n\n/**\n * Create a resolver that uses the email address to determine the agent to route the email to\n * @param defaultAgentName The default agent name to use if the email address does not contain a sub-address\n * @returns A function that resolves the agent to route the email to\n */\nexport function createAddressBasedEmailResolver<Env>(\n  defaultAgentName: string\n): EmailResolver<Env> {\n  return async (email: ForwardableEmailMessage, _env: Env) => {\n    const emailMatch = email.to.match(/^([^+@]+)(?:\\+([^@]+))?@(.+)$/);\n    if (!emailMatch) {\n      return null;\n    }\n\n    const [, localPart, subAddress] = emailMatch;\n\n    if (subAddress) {\n      return {\n        agentName: localPart,\n        agentId: subAddress\n      };\n    }\n\n    // Option 2: Use defaultAgentName namespace, localPart as agentId\n    // Common for catch-all email routing to a single EmailAgent namespace\n    return {\n      agentName: defaultAgentName,\n      agentId: localPart\n    };\n  };\n}\n\n/**\n * Create a resolver that uses the agentName and agentId to determine the agent to route the email to\n * @param agentName The name of the agent to route the email to\n * @param agentId The id of the agent to route the email to\n * @returns A function that resolves the agent to route the email to\n */\nexport function createCatchAllEmailResolver<Env>(\n  agentName: string,\n  agentId: string\n): EmailResolver<Env> {\n  return async () => ({ agentName, agentId });\n}\n\nexport type EmailRoutingOptions<Env> = AgentOptions<Env> & {\n  resolver: EmailResolver<Env>;\n};\n\n// Cache the agent namespace map for email routing\n// This maps both kebab-case and original names to namespaces\nconst agentMapCache = new WeakMap<\n  Record<string, unknown>,\n  Record<string, unknown>\n>();\n\n/**\n * Route an email to the appropriate Agent\n * @param email The email to route\n * @param env The environment containing the Agent bindings\n * @param options The options for routing the email\n * @returns A promise that resolves when the email has been routed\n */\nexport async function routeAgentEmail<Env>(\n  email: ForwardableEmailMessage,\n  env: Env,\n  options: EmailRoutingOptions<Env>\n): Promise<void> {\n  const routingInfo = await options.resolver(email, env);\n\n  if (!routingInfo) {\n    console.warn(\"No routing information found for email, dropping message\");\n    return;\n  }\n\n  // Build a map that includes both original names and kebab-case versions\n  if (!agentMapCache.has(env as Record<string, unknown>)) {\n    const map: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(env as Record<string, unknown>)) {\n      if (\n        value &&\n        typeof value === \"object\" &&\n        \"idFromName\" in value &&\n        typeof value.idFromName === \"function\"\n      ) {\n        // Add both the original name and kebab-case version\n        map[key] = value;\n        map[camelCaseToKebabCase(key)] = value;\n      }\n    }\n    agentMapCache.set(env as Record<string, unknown>, map);\n  }\n\n  const agentMap = agentMapCache.get(env as Record<string, unknown>)!;\n  const namespace = agentMap[routingInfo.agentName];\n\n  if (!namespace) {\n    // Provide helpful error message listing available agents\n    const availableAgents = Object.keys(agentMap)\n      .filter((key) => !key.includes(\"-\")) // Show only original names, not kebab-case duplicates\n      .join(\", \");\n    throw new Error(\n      `Agent namespace '${routingInfo.agentName}' not found in environment. Available agents: ${availableAgents}`\n    );\n  }\n\n  const agent = await getAgentByName(\n    namespace as unknown as AgentNamespace<Agent<Env>>,\n    routingInfo.agentId\n  );\n\n  // let's make a serialisable version of the email\n  const serialisableEmail: AgentEmail = {\n    getRaw: async () => {\n      const reader = email.raw.getReader();\n      const chunks: Uint8Array[] = [];\n\n      let done = false;\n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) {\n          chunks.push(value);\n        }\n      }\n\n      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n      const combined = new Uint8Array(totalLength);\n      let offset = 0;\n      for (const chunk of chunks) {\n        combined.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      return combined;\n    },\n    headers: email.headers,\n    rawSize: email.rawSize,\n    setReject: (reason: string) => {\n      email.setReject(reason);\n    },\n    forward: (rcptTo: string, headers?: Headers) => {\n      return email.forward(rcptTo, headers);\n    },\n    reply: (options: { from: string; to: string; raw: string }) => {\n      return email.reply(\n        new EmailMessage(options.from, options.to, options.raw)\n      );\n    },\n    from: email.from,\n    to: email.to\n  };\n\n  await agent._onEmail(serialisableEmail);\n}\n\nexport type AgentEmail = {\n  from: string;\n  to: string;\n  getRaw: () => Promise<Uint8Array>;\n  headers: Headers;\n  rawSize: number;\n  setReject: (reason: string) => void;\n  forward: (rcptTo: string, headers?: Headers) => Promise<void>;\n  reply: (options: { from: string; to: string; raw: string }) => Promise<void>;\n};\n\nexport type EmailSendOptions = {\n  to: string;\n  subject: string;\n  body: string;\n  contentType?: string;\n  headers?: Record<string, string>;\n  includeRoutingHeaders?: boolean;\n  agentName?: string;\n  agentId?: string;\n  domain?: string;\n};\n\n/**\n * Get or create an Agent by name\n * @template Env Environment type containing bindings\n * @template T Type of the Agent class\n * @param namespace Agent namespace\n * @param name Name of the Agent instance\n * @param options Options for Agent creation\n * @returns Promise resolving to an Agent instance stub\n */\nexport async function getAgentByName<\n  Env,\n  T extends Agent<Env>,\n  Props extends Record<string, unknown> = Record<string, unknown>\n>(\n  namespace: AgentNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n    props?: Props;\n  }\n) {\n  return getServerByName<Env, T>(namespace, name, options);\n}\n\n/**\n * A wrapper for streaming responses in callable methods\n */\nexport class StreamingResponse {\n  private _connection: Connection;\n  private _id: string;\n  private _closed = false;\n\n  constructor(connection: Connection, id: string) {\n    this._connection = connection;\n    this._id = id;\n  }\n\n  /**\n   * Send a chunk of data to the client\n   * @param chunk The data to send\n   */\n  send(chunk: unknown) {\n    if (this._closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    const response: RPCResponse = {\n      done: false,\n      id: this._id,\n      result: chunk,\n      success: true,\n      type: MessageType.RPC\n    };\n    this._connection.send(JSON.stringify(response));\n  }\n\n  /**\n   * End the stream and send the final chunk (if any)\n   * @param finalChunk Optional final chunk of data to send\n   */\n  end(finalChunk?: unknown) {\n    if (this._closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    this._closed = true;\n    const response: RPCResponse = {\n      done: true,\n      id: this._id,\n      result: finalChunk,\n      success: true,\n      type: MessageType.RPC\n    };\n    this._connection.send(JSON.stringify(response));\n  }\n}\n"],"mappings":"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"}