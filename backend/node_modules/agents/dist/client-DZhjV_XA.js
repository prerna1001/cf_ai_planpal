import { nanoid } from "nanoid";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { ElicitRequestSchema, PromptListChangedNotificationSchema, ResourceListChangedNotificationSchema, ToolListChangedNotificationSchema } from "@modelcontextprotocol/sdk/types.js";

//#region src/core/events.ts
function toDisposable(fn) {
	return { dispose: fn };
}
var DisposableStore = class {
	constructor() {
		this._items = [];
	}
	add(d) {
		this._items.push(d);
		return d;
	}
	dispose() {
		while (this._items.length) try {
			this._items.pop().dispose();
		} catch {}
	}
};
var Emitter = class {
	constructor() {
		this._listeners = /* @__PURE__ */ new Set();
		this.event = (listener) => {
			this._listeners.add(listener);
			return toDisposable(() => this._listeners.delete(listener));
		};
	}
	fire(data) {
		for (const listener of [...this._listeners]) try {
			listener(data);
		} catch (err) {
			console.error("Emitter listener error:", err);
		}
	}
	dispose() {
		this._listeners.clear();
	}
};

//#endregion
//#region src/mcp/errors.ts
function toErrorMessage(error) {
	return error instanceof Error ? error.message : String(error);
}
function isUnauthorized(error) {
	const msg = toErrorMessage(error);
	return msg.includes("Unauthorized") || msg.includes("401");
}
function isTransportNotImplemented(error) {
	const msg = toErrorMessage(error);
	return msg.includes("404") || msg.includes("405") || msg.includes("Not Implemented") || msg.includes("not implemented");
}

//#endregion
//#region src/mcp/client-connection.ts
var MCPClientConnection = class {
	constructor(url, info, options = {
		client: {},
		transport: {}
	}) {
		this.url = url;
		this.options = options;
		this.connectionState = "connecting";
		this.tools = [];
		this.prompts = [];
		this.resources = [];
		this.resourceTemplates = [];
		this._onObservabilityEvent = new Emitter();
		this.onObservabilityEvent = this._onObservabilityEvent.event;
		this.client = new Client(info, {
			...options.client,
			capabilities: {
				...options.client?.capabilities,
				elicitation: {}
			}
		});
	}
	/**
	* Initialize a client connection
	*
	* @returns
	*/
	async init() {
		const transportType = this.options.transport.type;
		if (!transportType) throw new Error("Transport type must be specified");
		try {
			await this.tryConnect(transportType);
		} catch (e) {
			if (isUnauthorized(e)) {
				this.connectionState = "authenticating";
				return;
			}
			this._onObservabilityEvent.fire({
				type: "mcp:client:connect",
				displayMessage: `Connection initialization failed for ${this.url.toString()}`,
				payload: {
					url: this.url.toString(),
					transport: transportType,
					state: this.connectionState,
					error: toErrorMessage(e)
				},
				timestamp: Date.now(),
				id: nanoid()
			});
			this.connectionState = "failed";
			return;
		}
		await this.discoverAndRegister();
	}
	/**
	* Finish OAuth by probing transports based on configured type.
	* - Explicit: finish on that transport
	* - Auto: try streamable-http, then sse on 404/405/Not Implemented
	*/
	async finishAuthProbe(code) {
		if (!this.options.transport.authProvider) throw new Error("No auth provider configured");
		const configuredType = this.options.transport.type;
		if (!configuredType) throw new Error("Transport type must be specified");
		const finishAuth = async (base) => {
			await this.getTransport(base).finishAuth(code);
		};
		if (configuredType === "sse" || configuredType === "streamable-http") {
			await finishAuth(configuredType);
			return;
		}
		try {
			await finishAuth("streamable-http");
		} catch (e) {
			if (isTransportNotImplemented(e)) {
				await finishAuth("sse");
				return;
			}
			throw e;
		}
	}
	/**
	* Complete OAuth authorization
	*/
	async completeAuthorization(code) {
		if (this.connectionState !== "authenticating") throw new Error("Connection must be in authenticating state to complete authorization");
		try {
			await this.finishAuthProbe(code);
			this.connectionState = "connecting";
		} catch (error) {
			this.connectionState = "failed";
			throw error;
		}
	}
	/**
	* Establish connection after successful authorization
	*/
	async establishConnection() {
		if (this.connectionState !== "connecting") throw new Error("Connection must be in connecting state to establish connection");
		try {
			const transportType = this.options.transport.type;
			if (!transportType) throw new Error("Transport type must be specified");
			await this.tryConnect(transportType);
			await this.discoverAndRegister();
		} catch (error) {
			this.connectionState = "failed";
			throw error;
		}
	}
	/**
	* Discover server capabilities and register tools, resources, prompts, and templates
	*/
	async discoverAndRegister() {
		this.connectionState = "discovering";
		this.serverCapabilities = this.client.getServerCapabilities();
		if (!this.serverCapabilities) throw new Error("The MCP Server failed to return server capabilities");
		const [instructionsResult, toolsResult, resourcesResult, promptsResult, resourceTemplatesResult] = await Promise.allSettled([
			this.client.getInstructions(),
			this.registerTools(),
			this.registerResources(),
			this.registerPrompts(),
			this.registerResourceTemplates()
		]);
		const operations = [
			{
				name: "instructions",
				result: instructionsResult
			},
			{
				name: "tools",
				result: toolsResult
			},
			{
				name: "resources",
				result: resourcesResult
			},
			{
				name: "prompts",
				result: promptsResult
			},
			{
				name: "resource templates",
				result: resourceTemplatesResult
			}
		];
		for (const { name, result } of operations) if (result.status === "rejected") {
			const url = this.url.toString();
			this._onObservabilityEvent.fire({
				type: "mcp:client:discover",
				displayMessage: `Failed to discover ${name} for ${url}`,
				payload: {
					url,
					capability: name,
					error: result.reason
				},
				timestamp: Date.now(),
				id: nanoid()
			});
		}
		this.instructions = instructionsResult.status === "fulfilled" ? instructionsResult.value : void 0;
		this.tools = toolsResult.status === "fulfilled" ? toolsResult.value : [];
		this.resources = resourcesResult.status === "fulfilled" ? resourcesResult.value : [];
		this.prompts = promptsResult.status === "fulfilled" ? promptsResult.value : [];
		this.resourceTemplates = resourceTemplatesResult.status === "fulfilled" ? resourceTemplatesResult.value : [];
		this.connectionState = "ready";
	}
	/**
	* Notification handler registration
	*/
	async registerTools() {
		if (!this.serverCapabilities || !this.serverCapabilities.tools) return [];
		if (this.serverCapabilities.tools.listChanged) this.client.setNotificationHandler(ToolListChangedNotificationSchema, async (_notification) => {
			this.tools = await this.fetchTools();
		});
		return this.fetchTools();
	}
	async registerResources() {
		if (!this.serverCapabilities || !this.serverCapabilities.resources) return [];
		if (this.serverCapabilities.resources.listChanged) this.client.setNotificationHandler(ResourceListChangedNotificationSchema, async (_notification) => {
			this.resources = await this.fetchResources();
		});
		return this.fetchResources();
	}
	async registerPrompts() {
		if (!this.serverCapabilities || !this.serverCapabilities.prompts) return [];
		if (this.serverCapabilities.prompts.listChanged) this.client.setNotificationHandler(PromptListChangedNotificationSchema, async (_notification) => {
			this.prompts = await this.fetchPrompts();
		});
		return this.fetchPrompts();
	}
	async registerResourceTemplates() {
		if (!this.serverCapabilities || !this.serverCapabilities.resources) return [];
		return this.fetchResourceTemplates();
	}
	async fetchTools() {
		let toolsAgg = [];
		let toolsResult = { tools: [] };
		do {
			toolsResult = await this.client.listTools({ cursor: toolsResult.nextCursor }).catch(this._capabilityErrorHandler({ tools: [] }, "tools/list"));
			toolsAgg = toolsAgg.concat(toolsResult.tools);
		} while (toolsResult.nextCursor);
		return toolsAgg;
	}
	async fetchResources() {
		let resourcesAgg = [];
		let resourcesResult = { resources: [] };
		do {
			resourcesResult = await this.client.listResources({ cursor: resourcesResult.nextCursor }).catch(this._capabilityErrorHandler({ resources: [] }, "resources/list"));
			resourcesAgg = resourcesAgg.concat(resourcesResult.resources);
		} while (resourcesResult.nextCursor);
		return resourcesAgg;
	}
	async fetchPrompts() {
		let promptsAgg = [];
		let promptsResult = { prompts: [] };
		do {
			promptsResult = await this.client.listPrompts({ cursor: promptsResult.nextCursor }).catch(this._capabilityErrorHandler({ prompts: [] }, "prompts/list"));
			promptsAgg = promptsAgg.concat(promptsResult.prompts);
		} while (promptsResult.nextCursor);
		return promptsAgg;
	}
	async fetchResourceTemplates() {
		let templatesAgg = [];
		let templatesResult = { resourceTemplates: [] };
		do {
			templatesResult = await this.client.listResourceTemplates({ cursor: templatesResult.nextCursor }).catch(this._capabilityErrorHandler({ resourceTemplates: [] }, "resources/templates/list"));
			templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);
		} while (templatesResult.nextCursor);
		return templatesAgg;
	}
	/**
	* Handle elicitation request from server
	* Automatically uses the Agent's built-in elicitation handling if available
	*/
	async handleElicitationRequest(_request) {
		throw new Error("Elicitation handler must be implemented for your platform. Override handleElicitationRequest method.");
	}
	/**
	* Get the transport for the client
	* @param transportType - The transport type to get
	* @returns The transport for the client
	*/
	getTransport(transportType) {
		switch (transportType) {
			case "streamable-http": return new StreamableHTTPClientTransport(this.url, this.options.transport);
			case "sse": return new SSEClientTransport(this.url, this.options.transport);
			default: throw new Error(`Unsupported transport type: ${transportType}`);
		}
	}
	async tryConnect(transportType) {
		const transports = transportType === "auto" ? ["streamable-http", "sse"] : [transportType];
		for (const currentTransportType of transports) {
			const isLastTransport = currentTransportType === transports[transports.length - 1];
			const hasFallback = transportType === "auto" && currentTransportType === "streamable-http" && !isLastTransport;
			const transport = this.getTransport(currentTransportType);
			try {
				await this.client.connect(transport);
				this.lastConnectedTransport = currentTransportType;
				const url = this.url.toString();
				this._onObservabilityEvent.fire({
					type: "mcp:client:connect",
					displayMessage: `Connected successfully using ${currentTransportType} transport for ${url}`,
					payload: {
						url,
						transport: currentTransportType,
						state: this.connectionState
					},
					timestamp: Date.now(),
					id: nanoid()
				});
				break;
			} catch (e) {
				const error = e instanceof Error ? e : new Error(String(e));
				if (isUnauthorized(error)) throw e;
				if (hasFallback && isTransportNotImplemented(error)) {
					const url = this.url.toString();
					this._onObservabilityEvent.fire({
						type: "mcp:client:connect",
						displayMessage: `${currentTransportType} transport not available, trying ${transports[transports.indexOf(currentTransportType) + 1]} for ${url}`,
						payload: {
							url,
							transport: currentTransportType,
							state: this.connectionState
						},
						timestamp: Date.now(),
						id: nanoid()
					});
					continue;
				}
				throw e;
			}
		}
		this.client.setRequestHandler(ElicitRequestSchema, async (request) => {
			return await this.handleElicitationRequest(request);
		});
	}
	_capabilityErrorHandler(empty, method) {
		return (e) => {
			if (e.code === -32601) {
				const url = this.url.toString();
				this._onObservabilityEvent.fire({
					type: "mcp:client:discover",
					displayMessage: `The server advertised support for the capability ${method.split("/")[0]}, but returned "Method not found" for '${method}' for ${url}`,
					payload: {
						url,
						capability: method.split("/")[0],
						error: toErrorMessage(e)
					},
					timestamp: Date.now(),
					id: nanoid()
				});
				return empty;
			}
			throw e;
		};
	}
};

//#endregion
//#region src/mcp/client.ts
/**
* Utility class that aggregates multiple MCP clients into one
*/
var MCPClientManager = class {
	/**
	* @param _name Name of the MCP client
	* @param _version Version of the MCP Client
	* @param auth Auth paramters if being used to create a DurableObjectOAuthClientProvider
	*/
	constructor(_name, _version) {
		this._name = _name;
		this._version = _version;
		this.mcpConnections = {};
		this._callbackUrls = [];
		this._didWarnAboutUnstableGetAITools = false;
		this._connectionDisposables = /* @__PURE__ */ new Map();
		this._onObservabilityEvent = new Emitter();
		this.onObservabilityEvent = this._onObservabilityEvent.event;
		this._onConnected = new Emitter();
		this.onConnected = this._onConnected.event;
	}
	/**
	* Connect to and register an MCP server
	*
	* @param transportConfig Transport config
	* @param clientConfig Client config
	* @param capabilities Client capabilities (i.e. if the client supports roots/sampling)
	*/
	async connect(url, options = {}) {
		/**
		* We need to delay loading ai sdk, because putting it in module scope is
		* causing issues with startup time.
		* The only place it's used is in getAITools, which only matters after
		* .connect() is called on at least one server.
		* So it's safe to delay loading it until .connect() is called.
		*/
		if (!this.jsonSchema) {
			const { jsonSchema } = await import("ai");
			this.jsonSchema = jsonSchema;
		}
		const id = options.reconnect?.id ?? nanoid(8);
		if (options.transport?.authProvider) {
			options.transport.authProvider.serverId = id;
			if (options.reconnect?.oauthClientId) options.transport.authProvider.clientId = options.reconnect?.oauthClientId;
		}
		if (!options.reconnect?.oauthCode || !this.mcpConnections[id]) {
			const normalizedTransport = {
				...options.transport,
				type: options.transport?.type ?? "auto"
			};
			this.mcpConnections[id] = new MCPClientConnection(new URL(url), {
				name: this._name,
				version: this._version
			}, {
				client: options.client ?? {},
				transport: normalizedTransport
			});
			const store = new DisposableStore();
			const existing = this._connectionDisposables.get(id);
			if (existing) existing.dispose();
			this._connectionDisposables.set(id, store);
			store.add(this.mcpConnections[id].onObservabilityEvent((event) => {
				this._onObservabilityEvent.fire(event);
			}));
		}
		await this.mcpConnections[id].init();
		if (options.reconnect?.oauthCode) try {
			await this.mcpConnections[id].completeAuthorization(options.reconnect.oauthCode);
			await this.mcpConnections[id].establishConnection();
		} catch (error) {
			this._onObservabilityEvent.fire({
				type: "mcp:client:connect",
				displayMessage: `Failed to complete OAuth reconnection for ${id} for ${url}`,
				payload: {
					url,
					transport: options.transport?.type ?? "auto",
					state: this.mcpConnections[id].connectionState,
					error: toErrorMessage(error)
				},
				timestamp: Date.now(),
				id
			});
			throw error;
		}
		const authUrl = options.transport?.authProvider?.authUrl;
		if (this.mcpConnections[id].connectionState === "authenticating" && authUrl && options.transport?.authProvider?.redirectUrl) {
			this._callbackUrls.push(options.transport.authProvider.redirectUrl.toString());
			return {
				authUrl,
				clientId: options.transport?.authProvider?.clientId,
				id
			};
		}
		return { id };
	}
	isCallbackRequest(req) {
		return req.method === "GET" && !!this._callbackUrls.find((url) => {
			return req.url.startsWith(url);
		});
	}
	async handleCallbackRequest(req) {
		const url = new URL(req.url);
		const urlMatch = this._callbackUrls.find((url$1) => {
			return req.url.startsWith(url$1);
		});
		if (!urlMatch) throw new Error(`No callback URI match found for the request url: ${req.url}. Was the request matched with \`isCallbackRequest()\`?`);
		const code = url.searchParams.get("code");
		const state = url.searchParams.get("state");
		const error = url.searchParams.get("error");
		const errorDescription = url.searchParams.get("error_description");
		const urlParams = urlMatch.split("/");
		const serverId = urlParams[urlParams.length - 1];
		if (error) return {
			serverId,
			authSuccess: false,
			authError: errorDescription || error
		};
		if (!code) throw new Error("Unauthorized: no code provided");
		if (!state) throw new Error("Unauthorized: no state provided");
		if (this.mcpConnections[serverId] === void 0) throw new Error(`Could not find serverId: ${serverId}`);
		if (this.mcpConnections[serverId].connectionState !== "authenticating") throw new Error("Failed to authenticate: the client isn't in the `authenticating` state");
		const conn = this.mcpConnections[serverId];
		if (!conn.options.transport.authProvider) throw new Error("Trying to finalize authentication for a server connection without an authProvider");
		const clientId = conn.options.transport.authProvider.clientId || state;
		conn.options.transport.authProvider.clientId = clientId;
		conn.options.transport.authProvider.serverId = serverId;
		try {
			await conn.completeAuthorization(code);
			return {
				serverId,
				authSuccess: true
			};
		} catch (error$1) {
			return {
				serverId,
				authSuccess: false,
				authError: error$1 instanceof Error ? error$1.message : String(error$1)
			};
		}
	}
	/**
	* Establish connection in the background after OAuth completion
	* This method is called asynchronously and doesn't block the OAuth callback response
	* @param serverId The server ID to establish connection for
	*/
	async establishConnection(serverId) {
		const conn = this.mcpConnections[serverId];
		if (!conn) {
			this._onObservabilityEvent.fire({
				type: "mcp:client:preconnect",
				displayMessage: `Connection not found for serverId: ${serverId}`,
				payload: { serverId },
				timestamp: Date.now(),
				id: nanoid()
			});
			return;
		}
		try {
			await conn.establishConnection();
			this._onConnected.fire(serverId);
		} catch (error) {
			const url = conn.url.toString();
			this._onObservabilityEvent.fire({
				type: "mcp:client:connect",
				displayMessage: `Failed to establish connection to server ${serverId} with url ${url}`,
				payload: {
					url,
					transport: conn.options.transport.type ?? "auto",
					state: conn.connectionState,
					error: toErrorMessage(error)
				},
				timestamp: Date.now(),
				id: nanoid()
			});
		}
	}
	/**
	* Register a callback URL for OAuth handling
	* @param url The callback URL to register
	*/
	registerCallbackUrl(url) {
		if (!this._callbackUrls.includes(url)) this._callbackUrls.push(url);
	}
	/**
	* Unregister a callback URL
	* @param serverId The server ID whose callback URL should be removed
	*/
	unregisterCallbackUrl(serverId) {
		this._callbackUrls = this._callbackUrls.filter((url) => !url.endsWith(`/${serverId}`));
	}
	/**
	* Configure OAuth callback handling
	* @param config OAuth callback configuration
	*/
	configureOAuthCallback(config) {
		this._oauthCallbackConfig = config;
	}
	/**
	* Get the current OAuth callback configuration
	* @returns The current OAuth callback configuration
	*/
	getOAuthCallbackConfig() {
		return this._oauthCallbackConfig;
	}
	/**
	* @returns namespaced list of tools
	*/
	listTools() {
		return getNamespacedData(this.mcpConnections, "tools");
	}
	/**
	* @returns a set of tools that you can use with the AI SDK
	*/
	getAITools() {
		return Object.fromEntries(getNamespacedData(this.mcpConnections, "tools").map((tool) => {
			return [`tool_${tool.serverId.replace(/-/g, "")}_${tool.name}`, {
				description: tool.description,
				execute: async (args) => {
					const result = await this.callTool({
						arguments: args,
						name: tool.name,
						serverId: tool.serverId
					});
					if (result.isError) throw new Error(result.content[0].text);
					return result;
				},
				inputSchema: this.jsonSchema(tool.inputSchema),
				outputSchema: tool.outputSchema ? this.jsonSchema(tool.outputSchema) : void 0
			}];
		}));
	}
	/**
	* @deprecated this has been renamed to getAITools(), and unstable_getAITools will be removed in the next major version
	* @returns a set of tools that you can use with the AI SDK
	*/
	unstable_getAITools() {
		if (!this._didWarnAboutUnstableGetAITools) {
			this._didWarnAboutUnstableGetAITools = true;
			console.warn("unstable_getAITools is deprecated, use getAITools instead. unstable_getAITools will be removed in the next major version.");
		}
		return this.getAITools();
	}
	/**
	* Closes all connections to MCP servers
	*/
	async closeAllConnections() {
		const ids = Object.keys(this.mcpConnections);
		await Promise.all(ids.map(async (id) => {
			await this.mcpConnections[id].client.close();
		}));
		for (const id of ids) {
			const store = this._connectionDisposables.get(id);
			if (store) store.dispose();
			this._connectionDisposables.delete(id);
			delete this.mcpConnections[id];
		}
	}
	/**
	* Closes a connection to an MCP server
	* @param id The id of the connection to close
	*/
	async closeConnection(id) {
		if (!this.mcpConnections[id]) throw new Error(`Connection with id "${id}" does not exist.`);
		await this.mcpConnections[id].client.close();
		delete this.mcpConnections[id];
		const store = this._connectionDisposables.get(id);
		if (store) store.dispose();
		this._connectionDisposables.delete(id);
	}
	/**
	* Dispose the manager and all resources.
	*/
	async dispose() {
		try {
			await this.closeAllConnections();
		} finally {
			this._onConnected.dispose();
			this._onObservabilityEvent.dispose();
		}
	}
	/**
	* @returns namespaced list of prompts
	*/
	listPrompts() {
		return getNamespacedData(this.mcpConnections, "prompts");
	}
	/**
	* @returns namespaced list of tools
	*/
	listResources() {
		return getNamespacedData(this.mcpConnections, "resources");
	}
	/**
	* @returns namespaced list of resource templates
	*/
	listResourceTemplates() {
		return getNamespacedData(this.mcpConnections, "resourceTemplates");
	}
	/**
	* Namespaced version of callTool
	*/
	async callTool(params, resultSchema, options) {
		const unqualifiedName = params.name.replace(`${params.serverId}.`, "");
		return this.mcpConnections[params.serverId].client.callTool({
			...params,
			name: unqualifiedName
		}, resultSchema, options);
	}
	/**
	* Namespaced version of readResource
	*/
	readResource(params, options) {
		return this.mcpConnections[params.serverId].client.readResource(params, options);
	}
	/**
	* Namespaced version of getPrompt
	*/
	getPrompt(params, options) {
		return this.mcpConnections[params.serverId].client.getPrompt(params, options);
	}
};
function getNamespacedData(mcpClients, type) {
	return Object.entries(mcpClients).map(([name, conn]) => {
		return {
			data: conn[type],
			name
		};
	}).flatMap(({ name: serverId, data }) => {
		return data.map((item) => {
			return {
				...item,
				serverId
			};
		});
	});
}

//#endregion
export { DisposableStore as i, getNamespacedData as n, MCPClientConnection as r, MCPClientManager as t };
//# sourceMappingURL=client-DZhjV_XA.js.map