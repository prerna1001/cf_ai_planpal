import { t as MessageType } from "./ai-types-B3aQaFv3.js";
import "./client-BfiZ3HQd.js";
import "./client-DZhjV_XA.js";
import "./do-oauth-client-provider-CswoD5Lu.js";
import { t as Agent } from "./src-C8K3lu37.js";
import { r as autoTransformMessages } from "./ai-chat-v5-migration-DBHGW4Hv.js";

//#region src/ai-chat-agent.ts
const decoder = new TextDecoder();
/**
* Extension of Agent with built-in chat capabilities
* @template Env Environment type containing bindings
*/
var AIChatAgent = class extends Agent {
	constructor(ctx, env) {
		super(ctx, env);
		this.sql`create table if not exists cf_ai_chat_agent_messages (
      id text primary key,
      message text not null,
      created_at datetime default current_timestamp
    )`;
		this.messages = autoTransformMessages(this._loadMessagesFromDb());
		this._chatMessageAbortControllers = /* @__PURE__ */ new Map();
	}
	_broadcastChatMessage(message, exclude) {
		this.broadcast(JSON.stringify(message), exclude);
	}
	_loadMessagesFromDb() {
		return (this.sql`select * from cf_ai_chat_agent_messages order by created_at` || []).map((row) => {
			try {
				return JSON.parse(row.message);
			} catch (error) {
				console.error(`Failed to parse message ${row.id}:`, error);
				return null;
			}
		}).filter((msg) => msg !== null);
	}
	async onMessage(connection, message) {
		if (typeof message === "string") {
			let data;
			try {
				data = JSON.parse(message);
			} catch (_error) {
				return;
			}
			if (data.type === MessageType.CF_AGENT_USE_CHAT_REQUEST && data.init.method === "POST") {
				const { body } = data.init;
				const { messages } = JSON.parse(body);
				const transformedMessages = autoTransformMessages(messages);
				this._broadcastChatMessage({
					messages: transformedMessages,
					type: MessageType.CF_AGENT_CHAT_MESSAGES
				}, [connection.id]);
				await this.persistMessages(transformedMessages, [connection.id]);
				this.observability?.emit({
					displayMessage: "Chat message request",
					id: data.id,
					payload: {},
					timestamp: Date.now(),
					type: "message:request"
				}, this.ctx);
				const chatMessageId = data.id;
				const abortSignal = this._getAbortSignal(chatMessageId);
				return this._tryCatchChat(async () => {
					const response = await this.onChatMessage(async (_finishResult) => {
						this._removeAbortController(chatMessageId);
						this.observability?.emit({
							displayMessage: "Chat message response",
							id: data.id,
							payload: {},
							timestamp: Date.now(),
							type: "message:response"
						}, this.ctx);
					}, abortSignal ? { abortSignal } : void 0);
					if (response) await this._reply(data.id, response);
					else {
						console.warn(`[AIChatAgent] onChatMessage returned no response for chatMessageId: ${chatMessageId}`);
						this._broadcastChatMessage({
							body: "No response was generated by the agent.",
							done: true,
							id: data.id,
							type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
						}, [connection.id]);
					}
				});
			}
			if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) {
				this._destroyAbortControllers();
				this.sql`delete from cf_ai_chat_agent_messages`;
				this.messages = [];
				this._broadcastChatMessage({ type: MessageType.CF_AGENT_CHAT_CLEAR }, [connection.id]);
			} else if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) {
				const transformedMessages = autoTransformMessages(data.messages);
				await this.persistMessages(transformedMessages, [connection.id]);
			} else if (data.type === MessageType.CF_AGENT_CHAT_REQUEST_CANCEL) this._cancelChatRequest(data.id);
		}
	}
	async onRequest(request) {
		return this._tryCatchChat(() => {
			if (new URL(request.url).pathname.endsWith("/get-messages")) {
				const messages = this._loadMessagesFromDb();
				return Response.json(messages);
			}
			return super.onRequest(request);
		});
	}
	async _tryCatchChat(fn) {
		try {
			return await fn();
		} catch (e) {
			throw this.onError(e);
		}
	}
	/**
	* Handle incoming chat messages and generate a response
	* @param onFinish Callback to be called when the response is finished
	* @param options.signal A signal to pass to any child requests which can be used to cancel them
	* @returns Response to send to the client or undefined
	*/
	async onChatMessage(onFinish, options) {
		throw new Error("recieved a chat message, override onChatMessage and return a Response to send to the client");
	}
	/**
	* Save messages on the server side
	* @param messages Chat messages to save
	*/
	async saveMessages(messages) {
		await this.persistMessages(messages);
		await this._tryCatchChat(async () => {
			const response = await this.onChatMessage(() => {});
			if (response) this._reply(crypto.randomUUID(), response);
		});
	}
	async persistMessages(messages, excludeBroadcastIds = []) {
		for (const message of messages) this.sql`
        insert into cf_ai_chat_agent_messages (id, message)
        values (${message.id}, ${JSON.stringify(message)})
        on conflict(id) do update set message = excluded.message
      `;
		this.messages = autoTransformMessages(this._loadMessagesFromDb());
		this._broadcastChatMessage({
			messages,
			type: MessageType.CF_AGENT_CHAT_MESSAGES
		}, excludeBroadcastIds);
	}
	async _reply(id, response) {
		return this._tryCatchChat(async () => {
			if (!response.body) {
				this._broadcastChatMessage({
					body: "",
					done: true,
					id,
					type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
				});
				return;
			}
			const { getToolName, isToolUIPart, parsePartialJson } = await import("ai");
			const reader = response.body.getReader();
			const message = {
				id: `assistant_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`,
				role: "assistant",
				parts: []
			};
			let activeTextParts = {};
			let activeReasoningParts = {};
			const partialToolCalls = {};
			function updateDynamicToolPart(options) {
				const part = message.parts.find((part$1) => part$1.type === "dynamic-tool" && part$1.toolCallId === options.toolCallId);
				const anyOptions = options;
				const anyPart = part;
				if (part != null) {
					part.state = options.state;
					anyPart.toolName = options.toolName;
					anyPart.input = anyOptions.input;
					anyPart.output = anyOptions.output;
					anyPart.errorText = anyOptions.errorText;
					anyPart.rawInput = anyOptions.rawInput ?? anyPart.rawInput;
					anyPart.preliminary = anyOptions.preliminary;
					if (anyOptions.providerMetadata != null && part.state === "input-available") part.callProviderMetadata = anyOptions.providerMetadata;
				} else message.parts.push({
					type: "dynamic-tool",
					toolName: options.toolName,
					toolCallId: options.toolCallId,
					state: options.state,
					input: anyOptions.input,
					output: anyOptions.output,
					errorText: anyOptions.errorText,
					preliminary: anyOptions.preliminary,
					...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
				});
			}
			function updateToolPart(options) {
				const part = message.parts.find((part$1) => isToolUIPart(part$1) && part$1.toolCallId === options.toolCallId);
				const anyOptions = options;
				const anyPart = part;
				if (part != null) {
					part.state = options.state;
					anyPart.input = anyOptions.input;
					anyPart.output = anyOptions.output;
					anyPart.errorText = anyOptions.errorText;
					anyPart.rawInput = anyOptions.rawInput;
					anyPart.preliminary = anyOptions.preliminary;
					anyPart.providerExecuted = anyOptions.providerExecuted ?? part.providerExecuted;
					if (anyOptions.providerMetadata != null && part.state === "input-available") part.callProviderMetadata = anyOptions.providerMetadata;
				} else message.parts.push({
					type: `tool-${options.toolName}`,
					toolCallId: options.toolCallId,
					state: options.state,
					input: anyOptions.input,
					output: anyOptions.output,
					rawInput: anyOptions.rawInput,
					errorText: anyOptions.errorText,
					providerExecuted: anyOptions.providerExecuted,
					preliminary: anyOptions.preliminary,
					...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
				});
			}
			async function updateMessageMetadata(metadata) {
				if (metadata != null) message.metadata = message.metadata != null ? {
					...message.metadata,
					...metadata
				} : metadata;
			}
			try {
				while (true) {
					const { done, value } = await reader.read();
					if (done) {
						this._broadcastChatMessage({
							body: "",
							done: true,
							id,
							type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
						});
						break;
					}
					const chunk = decoder.decode(value);
					if ((response.headers.get("content-type") || "").includes("text/event-stream")) {
						const lines = chunk.split("\n");
						for (const line of lines) if (line.startsWith("data: ") && line !== "data: [DONE]") try {
							const data = JSON.parse(line.slice(6));
							switch (data.type) {
								case "text-start": {
									const textPart = {
										type: "text",
										text: "",
										providerMetadata: data.providerMetadata,
										state: "streaming"
									};
									activeTextParts[data.id] = textPart;
									message.parts.push(textPart);
									break;
								}
								case "text-delta": {
									const textPart = activeTextParts[data.id];
									textPart.text += data.delta;
									textPart.providerMetadata = data.providerMetadata ?? textPart.providerMetadata;
									break;
								}
								case "text-end": {
									const textPart = activeTextParts[data.id];
									textPart.state = "done";
									textPart.providerMetadata = data.providerMetadata ?? textPart.providerMetadata;
									delete activeTextParts[data.id];
									break;
								}
								case "reasoning-start": {
									const reasoningPart = {
										type: "reasoning",
										text: "",
										providerMetadata: data.providerMetadata,
										state: "streaming"
									};
									activeReasoningParts[data.id] = reasoningPart;
									message.parts.push(reasoningPart);
									break;
								}
								case "reasoning-delta": {
									const reasoningPart = activeReasoningParts[data.id];
									reasoningPart.text += data.delta;
									reasoningPart.providerMetadata = data.providerMetadata ?? reasoningPart.providerMetadata;
									break;
								}
								case "reasoning-end": {
									const reasoningPart = activeReasoningParts[data.id];
									reasoningPart.providerMetadata = data.providerMetadata ?? reasoningPart.providerMetadata;
									reasoningPart.state = "done";
									delete activeReasoningParts[data.id];
									break;
								}
								case "file":
									message.parts.push({
										type: "file",
										mediaType: data.mediaType,
										url: data.url
									});
									break;
								case "source-url":
									message.parts.push({
										type: "source-url",
										sourceId: data.sourceId,
										url: data.url,
										title: data.title,
										providerMetadata: data.providerMetadata
									});
									break;
								case "source-document":
									message.parts.push({
										type: "source-document",
										sourceId: data.sourceId,
										mediaType: data.mediaType,
										title: data.title,
										filename: data.filename,
										providerMetadata: data.providerMetadata
									});
									break;
								case "tool-input-start": {
									const toolInvocations = message.parts.filter(isToolUIPart);
									partialToolCalls[data.toolCallId] = {
										text: "",
										toolName: data.toolName,
										index: toolInvocations.length,
										dynamic: data.dynamic
									};
									if (data.dynamic) updateDynamicToolPart({
										toolCallId: data.toolCallId,
										toolName: data.toolName,
										state: "input-streaming",
										input: void 0
									});
									else updateToolPart({
										toolCallId: data.toolCallId,
										toolName: data.toolName,
										state: "input-streaming",
										input: void 0
									});
									break;
								}
								case "tool-input-delta": {
									const partialToolCall = partialToolCalls[data.toolCallId];
									partialToolCall.text += data.inputTextDelta;
									const partialArgs = (await parsePartialJson(partialToolCall.text)).value;
									if (partialToolCall.dynamic) updateDynamicToolPart({
										toolCallId: data.toolCallId,
										toolName: partialToolCall.toolName,
										state: "input-streaming",
										input: partialArgs
									});
									else updateToolPart({
										toolCallId: data.toolCallId,
										toolName: partialToolCall.toolName,
										state: "input-streaming",
										input: partialArgs
									});
									break;
								}
								case "tool-input-available":
									if (data.dynamic) updateDynamicToolPart({
										toolCallId: data.toolCallId,
										toolName: data.toolName,
										state: "input-available",
										input: data.input,
										providerMetadata: data.providerMetadata
									});
									else updateToolPart({
										toolCallId: data.toolCallId,
										toolName: data.toolName,
										state: "input-available",
										input: data.input,
										providerExecuted: data.providerExecuted,
										providerMetadata: data.providerMetadata
									});
									break;
								case "tool-input-error":
									if (data.dynamic) updateDynamicToolPart({
										toolCallId: data.toolCallId,
										toolName: data.toolName,
										state: "output-error",
										input: data.input,
										errorText: data.errorText,
										providerMetadata: data.providerMetadata
									});
									else updateToolPart({
										toolCallId: data.toolCallId,
										toolName: data.toolName,
										state: "output-error",
										input: void 0,
										rawInput: data.input,
										errorText: data.errorText,
										providerExecuted: data.providerExecuted,
										providerMetadata: data.providerMetadata
									});
									break;
								case "tool-output-available":
									if (data.dynamic) {
										const toolInvocation = message.parts.filter((part) => part.type === "dynamic-tool").find((invocation) => invocation.toolCallId === data.toolCallId);
										if (!toolInvocation) throw new Error("Tool invocation not found");
										updateDynamicToolPart({
											toolCallId: data.toolCallId,
											toolName: toolInvocation.toolName,
											state: "output-available",
											input: toolInvocation.input,
											output: data.output,
											preliminary: data.preliminary
										});
									} else {
										const toolInvocation = message.parts.filter(isToolUIPart).find((invocation) => invocation.toolCallId === data.toolCallId);
										if (!toolInvocation) throw new Error("Tool invocation not found");
										updateToolPart({
											toolCallId: data.toolCallId,
											toolName: getToolName(toolInvocation),
											state: "output-available",
											input: toolInvocation.input,
											output: data.output,
											providerExecuted: data.providerExecuted,
											preliminary: data.preliminary
										});
									}
									break;
								case "tool-output-error":
									if (data.dynamic) {
										const toolInvocation = message.parts.filter((part) => part.type === "dynamic-tool").find((invocation) => invocation.toolCallId === data.toolCallId);
										if (!toolInvocation) throw new Error("Tool invocation not found");
										updateDynamicToolPart({
											toolCallId: data.toolCallId,
											toolName: toolInvocation.toolName,
											state: "output-error",
											input: toolInvocation.input,
											errorText: data.errorText
										});
									} else {
										const toolInvocation = message.parts.filter(isToolUIPart).find((invocation) => invocation.toolCallId === data.toolCallId);
										if (!toolInvocation) throw new Error("Tool invocation not found");
										updateToolPart({
											toolCallId: data.toolCallId,
											toolName: getToolName(toolInvocation),
											state: "output-error",
											input: toolInvocation.input,
											rawInput: "rawInput" in toolInvocation ? toolInvocation.rawInput : void 0,
											errorText: data.errorText
										});
									}
									break;
								case "start-step":
									message.parts.push({ type: "step-start" });
									break;
								case "finish-step":
									activeTextParts = {};
									activeReasoningParts = {};
									break;
								case "start":
									if (data.messageId != null) message.id = data.messageId;
									await updateMessageMetadata(data.messageMetadata);
									break;
								case "finish":
									await updateMessageMetadata(data.messageMetadata);
									break;
								case "message-metadata":
									await updateMessageMetadata(data.messageMetadata);
									break;
								case "error":
									this._broadcastChatMessage({
										error: true,
										body: data.errorText ?? JSON.stringify(data),
										done: false,
										id,
										type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
									});
									break;
							}
							this._broadcastChatMessage({
								body: JSON.stringify(data),
								done: false,
								id,
								type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
							});
						} catch (_e) {}
					} else if (chunk.length > 0) {
						message.parts.push({
							type: "text",
							text: chunk
						});
						this._broadcastChatMessage({
							body: JSON.stringify({
								type: "text-delta",
								delta: chunk
							}),
							done: false,
							id,
							type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
						});
					}
				}
			} finally {
				reader.releaseLock();
			}
			if (message.parts.length > 0) await this.persistMessages([...this.messages, message]);
		});
	}
	/**
	* For the given message id, look up its associated AbortController
	* If the AbortController does not exist, create and store one in memory
	*
	* returns the AbortSignal associated with the AbortController
	*/
	_getAbortSignal(id) {
		if (typeof id !== "string") return;
		if (!this._chatMessageAbortControllers.has(id)) this._chatMessageAbortControllers.set(id, new AbortController());
		return this._chatMessageAbortControllers.get(id)?.signal;
	}
	/**
	* Remove an abort controller from the cache of pending message responses
	*/
	_removeAbortController(id) {
		this._chatMessageAbortControllers.delete(id);
	}
	/**
	* Propagate an abort signal for any requests associated with the given message id
	*/
	_cancelChatRequest(id) {
		if (this._chatMessageAbortControllers.has(id)) this._chatMessageAbortControllers.get(id)?.abort();
	}
	/**
	* Abort all pending requests and clear the cache of AbortControllers
	*/
	_destroyAbortControllers() {
		for (const controller of this._chatMessageAbortControllers.values()) controller?.abort();
		this._chatMessageAbortControllers.clear();
	}
	/**
	* When the DO is destroyed, cancel all pending requests
	*/
	async destroy() {
		this._destroyAbortControllers();
		await super.destroy();
	}
};

//#endregion
export { AIChatAgent };
//# sourceMappingURL=ai-chat-agent.js.map